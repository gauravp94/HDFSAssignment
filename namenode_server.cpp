/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "namenode.h"

char **
openfile_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;

	/*
	 * insert server code here
	 */

	return &result;
}

char **
getblocklocations_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;

	/*
	 * insert server code here
	 */

	return &result;
}

char **
assignblock_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;

	/*
	 * insert server code here
	 */

	return &result;
}

char **
closefile_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;

	/*
	 * insert server code here
	 */

	return &result;
}

char **
list_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;
	ListFilesRequest l;
	ListFilesResponse lr = new ListFilesResponse();
	string dir_name = l.dirName();
	map<string, vector<int> >::iterator it;
	vector<string> ans;
	//set<int> setOfBlocks;
	for(it = filename_block_map.begin();it!=filename_block_map.end();it++)
	{
		string fname = it->first;
		ans.append(fname);
		// vector<int> blocks = it->second;
		// copy( blocks.begin(), blocks.end(), std::inserter( setOfBlocks, setOfBlocks.end() ) );
	}
	lr.set_status(1);
	for(int i=0;i<ans.size();i++)
	{
		lr.add_fileNames(ans[i]);
	}
	//lr.fileNames = ans;
	/*
	 * insert server code here
	 */
	string t;
	if (!lr.SerializeToString(t)) {
      cerr << "Failed to give BlockReportResponse."<< endl;
      return -1;
    }
    result = t.c_str();
	return &result;
}

char **
sendblockreport_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;
	BlockReportRequest b;
	BlockReportResponse op;
	int dataNodeId = b.id();
	string ip = b.blockLocations().ip();
	int port = b.blockLocations().port();
	vector<int> blockNos
	for(int i=0;i<b.blockNumbers_size();i++)
	{
		blockNos.append(b.blockNumbers(i));
	}
	/*
	 * insert server code here
	 */
	int blockNos_size = blockNos.size();
	for(int i =0;i<blockNos_size;i++)
	{
		//if vector doesn't exist
		if(block_datanode_map.find(blockNos[i]) == block_datanode_map.end())
		{
			vector<int> tmp(1,dataNodeId);
			block_datanode_map[blockNos[i]] = tmp;
		}
		else
		{
			//if vector exists but entry not 
			vector<int> tmp = block_datanode_map[blockNos[i]];
			tmp.append(dataNodeId);
			block_datanode_map[blockNos[i]] = tmp;
		}
	}
	op.set_status(1);
	string tmp;
	if (!op.SerializeToString(&tmp)) {
      cerr << "Failed to give BlockReportResponse."<< endl;
      return -1;
    }
    result = tmp.c_str();
	return &result;
}

char **
sendheartbeat_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;
	HeartBeatRequest r;
	int blockno = r.id();
	cout<<"got heartbeat from datanode :"<<blockno<<endl;

	HeartBeatResponse hr;
	hr.set_status(1);

	/*
	 * insert server code here
	 */
	string t;
	if (!hr.SerializeToString(t)) {
      cerr << "Failed to give HeartBeatResponse."<< endl;
      return -1;
    }
    result = t.c_str();
	return &result;
}

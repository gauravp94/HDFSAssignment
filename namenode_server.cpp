/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "namenode.h"
#include<map>
#include<vector>
using namespace std;

string TAG = "NN", FILE_LIST = "file_list.txt";
int blockNum = 0;
int fileNum = 0;
map<int, string> handle_filename_map;
map<string, vector<int> > filename_block_map;
map<int, vector<int> > block_datanode_map;
int dataNodeNum = 4;
vector<string> dataNodeIPs = {"127.0.0.1","127.0.0.1","127.0.0.1","127.0.0.1"};
vector<int> dataNodePorts = {1099,1099,1099,1099};

char **
openfile_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;
	ReadBlockRequest r;
	string filename = r.fileName;
	bool forRead = r.forRead;

	handle_filename_map[fileNum] = filename;

	readBlockResponse op = new readBlockResponse();
	op.status = 1;
	op.handle = fileNum;

	if(filename_block_map[filename] != NULL) {
		op.blockNums = filename_block_map[filename];
	}
	fileNum++;

	if(!op.SerilizeToString(result)){
		cerr << "Failed" << endl;
		return -1;
	}
	/*
	 * insert server code here
	 */

	return &result;
}

char **
getblocklocations_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;
	BlockLocationRequest ip = new blockLocationRequest();
	vector<int> blockNums = ip.blockNums;

	BlockLocationResponse op = new BlockLocationResponse();
	op.status = 1;

	BlockLocations bl = new BlockLocations();


	/*
	 * insert server code here
	 */

	return &result;
}

char **
assignblock_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;
	AssignBlockRequest ip = new AssignBlockRequest();
	int handle = ip.handle;
	string filename = handle_filename_map[handle];
	if(filename_block_map[filename] != NULL) {
		filename_block_map[filename] = blockNum;
	} else {
		vector<int> a;
		a.push_back(blockNum);
		filename_block_map[filename] = a;
	}

	BlockLocations bl = new BlockLocations();
	DataNodeLocation dnl = new DataNodeLocation();

	int datanode1=0, datanode2=0;
	datanode1 = rand()%4+1;
	while(datanode2 == datanode1) {
		datanode2 = rand()%4+1;
	}
	cout << datanode1 + " " + datanode2 << endl;

	bl.blockNumber = blockNum;
	dnl.set_ip(dataNodeIPs[datanode1]);
	dnl.set_port(dataNodeIPs[datanode1]);
	dnl.add_locations();

	dnl.set_ip(dataNodeIPs[datanode2]);
	dnl.set_port(dataNodeIPs[datanode2]);
	dnl.add_locations();

	vector<int> blockNums = {datanode1, datanode2};
	block_datanode_map[blockNum] = blockNums;

	AssignBlockResponse op = new AssignBlockResponse();
	op.set_status(1);
	op.set_allocated_newblock();

	/*
	 * insert server code here
	 */
	 if(!op.SerilizeToString(result)){
 		cerr << "Failed" << endl;
 		return -1;
 	}
	return &result;
}

char **
closefile_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;
	CloseFileRequest ip = new CloseFileRequest();
	int handle = ip.handle;

	string filename = handle_filename_map[handle];
	vector<int> blockList = filename_block_map[filename];

	ofstream out;
	out.open(FILE_LIST, ios_base::app);
	out << filename+" ";

	for(int i=0; i<blockList.size(); i++) {
		out << to_string(blockList[i]+" ");
	}
	out << endl;
	out.close();

	CloseFileResponse op = new CloseFileResponse();
	op.status = 1;
	/*
	 * insert server code here
	 */
	 if(!op.SerilizeToString(result)){
 		cerr << "Failed" << endl;
 		return -1;
 	}

	return &result;
}

char **
list_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;
	ListFilesRequest l;
	ListFilesResponse lr = new ListFilesResponse();
	string dir_name = l.dirName();
	map<string, vector<int> >::iterator it;
	vector<string> ans;
	//set<int> setOfBlocks;
	for(it = filename_block_map.begin();it!=filename_block_map.end();it++)
	{
		string fname = it->first;
		ans.append(fname);
		// vector<int> blocks = it->second;
		// copy( blocks.begin(), blocks.end(), std::inserter( setOfBlocks, setOfBlocks.end() ) );
	}
	lr.set_status(1);
	for(int i=0;i<ans.size();i++)
	{
		lr.add_fileNames(ans[i]);
	}
	//lr.fileNames = ans;
	/*
	 * insert server code here
	 */
	string t;
	if (!lr.SerializeToString(t)) {
      cerr << "Failed to give BlockReportResponse."<< endl;
      return -1;
    }
    result = t.c_str();
	return &result;
}

char **
sendblockreport_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;
	BlockReportRequest b;
	BlockReportResponse op;
	int dataNodeId = b.id();
	string ip = b.blockLocations().ip();
	int port = b.blockLocations().port();
	vector<int> blockNos
	for(int i=0;i<b.blockNumbers_size();i++)
	{
		blockNos.append(b.blockNumbers(i));
	}
	/*
	 * insert server code here
	 */
	int blockNos_size = blockNos.size();
	for(int i =0;i<blockNos_size;i++)
	{
		//if vector doesn't exist
		if(block_datanode_map.find(blockNos[i]) == block_datanode_map.end())
		{
			vector<int> tmp(1,dataNodeId);
			block_datanode_map[blockNos[i]] = tmp;
		}
		else
		{
			//if vector exists but entry not 
			vector<int> tmp = block_datanode_map[blockNos[i]];
			tmp.append(dataNodeId);
			block_datanode_map[blockNos[i]] = tmp;
		}
	}
	op.set_status(1);
	string tmp;
	if (!op.SerializeToString(&tmp)) {
      cerr << "Failed to give BlockReportResponse."<< endl;
      return -1;
    }
    result = tmp.c_str();
	return &result;
}

char **
sendheartbeat_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;
	HeartBeatRequest r;
	int blockno = r.id();
	cout<<"got heartbeat from datanode :"<<blockno<<endl;

	HeartBeatResponse hr;
	hr.set_status(1);

	/*
	 * insert server code here
	 */
	string t;
	if (!hr.SerializeToString(t)) {
      cerr << "Failed to give HeartBeatResponse."<< endl;
      return -1;
    }
    result = t.c_str();
	return &result;
}
